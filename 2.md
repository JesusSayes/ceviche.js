# Capítulo 2: Funciones

> Con lo aprendido en el capítulo anterior has iniciado con buen pie la tarea de desarrollar el sitio web de La Buena Espina, pero aún tienes camino por recorrer si deseas crear un sitio web fácilmente mantenible en el futuro.
>
> Para lograr una buena estructura en cualquier tipo de proyecto es necesario hacer uso de algunos patrones de diseño, que son soluciones probadas a situaciones comunes en todo tipo de sitio o aplicación web. Estos patrones utilizan funciones a un nivel más avanzado de lo visto en el capítulo anterior, que es justo de lo que trata esta parte.

## Funciones
Las funciones en JavaScript también son objetos, por lo que tienen propiedades y métodos. Además de ser objetos, son llamadas *ciudadanos de primera clase* (*first-class citizen*), el tipo de estructura más importante en un lenguaje, así que pueden ser pasadas como parámetros (*callbacks*), ser asignadas a una variable (constructores y funciones anónimas) o ser retornadas por otra función (*closures*).

En JavaScript se pueden crear funciones de 3 formas:

A. Declarando una función, con la sentencia `function`:
```javascript
function suma(a, b) {
  return a + b;
};

suma(1, 2);
```

B. Expresando una función, con el operador `function`:
```javascript
var suma = function suma(a, b) {
  return a + b;
};

suma(1, 2);
```

C. Creando una instancia del constructor `Function`:
```javascript
var suma = new Function('a', 'b', 'return a + b');

suma(1, 2);
```

La forma A y B son similares en sintaxis. Sin embargo, la diferencia principal se da en cómo el navegador carga las funciones. En el primer caso, el navegador cargará todas las funciones declaradas y luego ejecutará el código en el orden en el que fue escrito, mientras que en el segundo caso, la función se cargará según la posición donde esté definida.

La forma C tiene la ventaja de permitir *evaluar sentencias en tiempo de ejecución*. Esto quiere decir que se pueden crear y ejecutar funciones a partir de datos que ingrese un usuario, como en el caso de una [consola de JavaScript](http://hpneo.github.io/consola.js/).

### Scope y context
Una de las más grandes diferencias en JavaScript con respecto a los lenguajes de los cuales está influido es en el ámbito (*scope*) y en el contexto de función.

El ámbito de una variable es el lugar dentro de un programa en el cual dicha variable vive y por lo tanto, donde puede ser usada. El scope de una variable es a nivel de funciones, lo que significa que una variable definida dentro de una función (con la palabra reservada `var`) va a poder ser usada dentro de esa función, pero no fuera de la misma.

Por otro lado, no es recomendable declarar variables sin `var` ya que, si se omite esta palabra reservada, el programa buscará la variable en los ámbitos (o *scopes*) superiores hasta llegar al ámbito global. Si la variable existe, reemplaza su valor, y si no existe la crea en el ámbito global:

```javascript
function globalFunction() {
  function innerFunction() {
    function deeperFunction() {
      globalVar = 'globalVar'; // sin `var`, `globalVar` se vuelve global
    };

    deeperFunction();
    console.log('deeperFunction', globalVar);
  };

  innerFunction();
  console.log('innerFunction', globalVar);
};

globalFunction();
console.log('globalFunction', globalVar);

// deeperFunction globalVar
// innerFunction globalVar
// globalFunction globalVar
```

El contexto dentro de una función puede cambiar de valor, de acuerdo a la forma cómo está definida la función y cómo se la ejecuta. El contexto es el “dueño” del ámbito de la función que se está ejecutando y se puede acceder a él mediante la palabra reservada `this`.

El contexto cambia de valor según los siguientes casos:

A. Cuando se define una función como método de un objeto, el contexto de dicha función es el objeto:

```javascript
var obj = {
  propiedad: 'valor'
};

obj.devolverValor = function() {
  console.log('contexto: ', this);
  return this.propiedad;
};

obj.devolverValor();
// contexto:  Object {propiedad: "valor", devolverValor: function}
// "valor"
```

B. Cuando la función es una función constructora, el contexto de dicha función es el objeto instanciado usando dicha función:

```javascript
var Constructor = function Constructor(nuevoValor) {
  this.propiedad = nuevoValor;
  
  console.log('contexto: ', this);
};

var obj = new Constructor('valor');
// contexto:  Constructor {propiedad: "valor"}
obj;
// Constructor {propiedad: "valor"}
obj.propiedad = 'valor';
// "valor"
```

C. Cuando la función solo es una función (creada de las 3 formas explicadas anteriormente), el contexto es el contexto global, el cual en navegadores es `window`.

```javascript
function contextoGlobal1() {
  console.log('contexto1: ', this);
};

var contextoGlobal2 = function() {
  console.log('contexto2: ', this);
};

var contextoGlobal3 = new Function("console.log('contexto3: ', this);");

contextoGlobal1();
// contexto1: Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…}
contextoGlobal2();
// contexto2: Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…}
contextoGlobal3();
// contexto3: Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…}
```

En JavaScript se puede ejecutar una función y cambiar el contexto utilizando los métodos `call` y `apply`. Ambos métodos, que también son funciones, son similares en propósito, pero difieren en el número y forma de sus parámetros.

```javascript
function buildSiteTitle(part1, part2) {
  return part1 + ' — ' + part2;
};

buildSiteTitle('La Buena Espina', 'Carta');
// "La Buena Espina — Ceviches"
buildSiteTitle.call(null, 'La Buena Espina', 'Locales');
// "La Buena Espina — Locales"
buildSiteTitle.apply(null, ['La Buena Espina', 'Historia']);
// "La Buena Espina — Historia"
```

`call` y `apply` tienen como primer argumento el nuevo contexto de la función, el cual en este caso es `null` debido a que no es necesario tener un contexto definido para este ejemplo. Para el caso de `call` el resto de argumentos deben ser los mismos de la función al ser ejecutada, mientras que para el caso de `apply` solo toma un segundo argumento, un arreglo, el cual contiene todos los argumentos de la función a ejecutar.

`apply` tiene una ventaja con respecto a `call`, que es permitir pasar los argumentos de forma dinámica. En el caso de `call`, cada parámetro debe ser pasado dentro del método, como un parámetro más; en el caso de `apply`, solo basta agregar un elemento en el segundo parámetro, que es un arreglo.

```javascript
var titleParts = [];

titleParts.push('La Buena Espina');
buildSiteTitle.apply(null, titleParts);
// "La Buena Espina — undefined"

titleParts.push('Historia');
buildSiteTitle.apply(null, titleParts);
// "La Buena Espina — Historia"
```

Esta flexibilidad al momento de pasar los argumentos en una función se ve limitada hasta este punto. Es aquí donde se empieza a utilizar la palabra reservada `arguments`, el cual es un objeto que representa a los argumentos de la función que se está ejecutando en ese instante.

```javascript
function buildSiteTitle() {     // Ya no es necesario definir los parámetros
  var separator = ' — ';
  var title = '';

  if (arguments.length > 2) {   // arguments tiene una propiedad llamada length
    separator = ' › ';
  }
  
  for (var i = 0; i < arguments.length; i++) {
    if (i == 0) {
      title += arguments[i];    // La primera parte del título no debe tener separador
    }
    else {
      title += separator + arguments[i];
    }
  }
  
  return title;
};

buildSiteTitle.apply(null, ['La Buena Espina', 'Historia']);
// "La Buena Espina — Historia"

buildSiteTitle.apply(null, ['La Buena Espina', 'Menú', 'Ceviches']);
// "La Buena Espina › Menú › Ceviches"
```

---

Cabe notar que aunque `arguments` tiene una propiedad llamada `length` y puede ser iterada mediante una estructura `for`, no es un arreglo, si no un objeto cuyas propiedades son los argumentos de la función, y donde el nombre de cada propiedad es un índice que empieza en 0 y termina en un número igual a `length` menos uno.

---

### Funciones anónimas
Una función anónima es una función expresada con el operador `function` (forma B para crear funciones) y que no tiene nombre.

```javascript
var funcionConNombre = function funcionConNombre() {
  return 'función con nombre';
};

var funcionAnonima = function () {
  return 'función anónima';
};

funcionConNombre();
// función con nombre
funcionAnonima();
// "función anónima"
```

Este tipo de funciones suelen ser utilizadas como funciones inmediatamente invocadas y callbacks, ya que al ser una función sin nombre, se espera que sea de un solo uso.

### Funciones inmediatamente invocadas
Una función inmediatamente invocada (*Immediately-Invoked Function Expression - IIFE*) es una expresión que permite ejecutar una función anónima inmediatamente después de ser definida, lo cual hace que el valor devuelto por la expresión no sea la función en sí, si no el valor de su ejecución.

```javascript
var suma = (function(a, b) {
  return a + b;
})(10, 15);

suma;
// 25
```

La función anónima de este ejemplo está encerrada por paréntesis, lo que permite tratarla como un objeto más, de igual forma a que si esa misma función anónima esté asignada a una variable:

```javascript
var sumaFn = function(a, b) {
  return a + b;
};

sumaFn(10, 15);
// 25
```

En el caso de una función inmediatamente invocada, la función anónima es ejecutada una sola vez, por lo que no hay motivo para ser guardada en una variable.

### Funciones constructoras
Las funciones constructoras permiten definir una especie de “clase” en JavaScript, con la cual luego se pueden instanciar objetos que tengan propiedades y métodos en común.

```javascript
function Dish(options) {
  this.name = options.name;
  this.ingredients = options.ingredients;
  this.garnishes = options.garnishes;
  this.diners = options.diners;
};

var cevicheSimple = new Dish({
  name: 'Ceviche simple',
  ingredients: [
    '1 kilo de pescado',
    '2 cebollas',
    '1 taza de jugo de limón',
    '1 ají limo',
    'sal'
  ],
  garnishes: [
    'lechuga (2 hojas por plato)',
    'maíz cancha',
    '4 porciones de yuca',
    '4 choclos sancochados',
    'camote sancochado en rodajas (2 por plato)'
  ],
  diners: 4
});

cevicheSimple;
// Dish {name: "Ceviche simple", ingredients: Array[5], garnishes: Array[5], diners: 4}

cevicheSimple instanceof Dish;
// true
```

## Objeto prototype
La orientación a objetos en JavaScript no se maneja mediante clases, si no utilizando funciones constructoras y *prototypes*. Mientras las primeras fungen de clases, las segundas permiten aplicar herencia simple.

## Patrones de diseño
Debido al auge que ha tenido JavaScript en los últimos años se hizo necesario crear y aplicar técnicas probadas que permitan escribir mejor código y solucionar problemas comunes. Estas técnicas son llamadas patrones de diseño y representan uno de los pilares en cuanto al desarrollo tanto de JavaScript como lenguaje como del uso que se le da al momento de crear aplicaciones web tanto del lado frontend como backend.

### Closure
Un closure en JavaScript es creado como una función definida dentro de otra función, teniendo la primera función (la función interna) acceso al ámbito (*scope*) de la función que la contiene (la función externa). En JavaScript este comportamiento no sucede a la inversa; es decir, una función externa no tiene acceso al ámbito de la función interna.

### Module
Un módulo utiliza las funciones inmediatamente invocadas para encapsular el comportamiento de una función y hacer públicos solo los métodos que se consideren necesarios, mientras que el resto de operaciones y variables quedan inaccesibles.

### Callbacks
Un callback es una función pasada como parámetro en otra función, la cual ejecuta la función callback luego de haber realizado sus propias operaciones. Usualmente los callbacks son funciones anónimas.

### Publish / Subscribe
El patrón publish / subscribe permite la comunicación entre objetos de forma asíncrona utilizando el envío de mensajes a través de canales definidos entre el objeto que envía dichos mensajes (*publisher*) y los objetos que los reciben (*subscribers*).
